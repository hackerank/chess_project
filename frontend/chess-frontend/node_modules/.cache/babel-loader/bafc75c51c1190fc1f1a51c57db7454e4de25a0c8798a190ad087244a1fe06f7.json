{"ast":null,"code":"import _objectSpread from\"C:/Users/think/Desktop/git_projects/chess_project/frontend/chess-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _classCallCheck from\"C:/Users/think/Desktop/git_projects/chess_project/frontend/chess-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";import _createClass from\"C:/Users/think/Desktop/git_projects/chess_project/frontend/chess-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";var Referee=/*#__PURE__*/function(){function Referee(){_classCallCheck(this,Referee);}_createClass(Referee,[{key:\"isStaleMate\",value:/**\r\n     * \r\n     * @param {*} boardState given boardState at which we want to calculate checkmate\r\n     * @param {*} team the team whose turn it is\r\n     * @returns \r\n     */function isStaleMate(boardState,team){var ret=true;var count=0;for(var i=0;i<boardState.length;++i){var piece=boardState[i];if(piece.team===team){for(var _i=0;_i<=7;++_i){for(var j=0;j<=7;j++){var a=this.isValidMove(piece.x,piece.y,j,_i,piece.type,piece.team,boardState,false);if(a){var newBoardState=this.getBoardStateAfterMove(piece.x,piece.y,_i,j,boardState);if(!this.inCheck(newBoardState,piece.team)){count++;//   console.log(piece);\n}}if(count>0){ret=false;break;}}if(count>0){ret=false;break;}}}if(count>0){ret=false;break;}}// console.log(`count = ${count}`);\nreturn ret;}/**\r\n     * given boardState and team we will calculate whether the given \"team\" is in checkmate or not\r\n        basically we want to calculate if the given \"team\" has any valid moves or not \r\n        if any one valid move is found (move can be anywhere on the board) then return false\r\n        else return true\r\n     * \r\n     * \r\n     * @param {*} boardState given boardState at which we want to calculate checkmate\r\n     * @param {*} team the team who is being checkmated\r\n     * @returns  true if checkmate , false otherwise\r\n     */},{key:\"inCheckMate\",value:function inCheckMate(boardState,team){var ret=true;var count=0;for(var i=0;i<boardState.length;++i){var piece=boardState[i];if(piece.team===team){for(var _i2=0;_i2<=7;++_i2){for(var j=0;j<=7;j++){var a=this.isValidMove(piece.x,piece.y,j,_i2,piece.type,piece.team,boardState,false);if(a){var newBoardState=this.getBoardStateAfterMove(piece.x,piece.y,_i2,j,boardState);if(!this.inCheck(newBoardState,piece.team)){count++;//   console.log(piece);\n}}if(count>0){ret=false;break;}}if(count>0){ret=false;break;}}}if(count>0){ret=false;break;}}// console.log(`count = ${count}`);\nreturn ret;}/**\r\n     * \r\n     * @param {*} boardState state of board at which we want to check for \"CHECK\"\r\n     * @param {*} team the team whose king is in check is to be checked\r\n     * @returns \r\n     */},{key:\"inCheck\",value:function inCheck(boardState,team){var oppteam=team===\"our\"?\"opponent\":\"our\";var king=boardState.find(function(p){return p.team===team&&p.type===\"king\";});if(!king){return false;}var ret=false;for(var i=0;i<boardState.length;++i){var piece=boardState[i];if(piece.team===oppteam){if(this.isValidMove(piece.x,piece.y,king.x,king.y,piece.type,piece.team,boardState,false)){ret=true;break;}}}return ret;}// if (referee.inCheck(referee.getBoardStateAfterMove(x, y, i, j, pieces), currentPiece.team, room, \"white\")) {\n//     continue;\n//   }\n//   else{\n/**\r\n     * \r\n     * @param {*} px  previous pos x\r\n     * @param {*} py previous pos y\r\n     * @param {*} fx final pos x\r\n     * @param {*} fy final pos y\r\n     * @param {*} boardState \r\n     * @returns  board state after move is made\r\n     */},{key:\"getBoardStateAfterMove\",value:function getBoardStateAfterMove(px,py,fy,fx,boardState){var ret=[];// if there is a piece on (fx,fy) we need to delete it\nboardState.forEach(function(ele){if(ele.x===fx&&ele.y===fy){// do nothing\n}else if(ele.x===px&&ele.y===py){var newEle=_objectSpread({},ele);newEle.y=fy;newEle.x=fx;ret.push(newEle);}else{var _newEle=_objectSpread({},ele);ret.push(_newEle);}});return ret;}},{key:\"isTileOccupied\",value:function isTileOccupied(x,y,boardState){var piece=boardState.find(function(p){return p.y===x&&p.x===y;});if(piece){return true;}return false;}},{key:\"isTileOccupiedByOpponent\",value:function isTileOccupiedByOpponent(x,y,boardState,team){var piece=boardState.find(function(p){return p.y===x&&p.x===y&&p.team!==team;});if(piece){return true;}return false;}},{key:\"isEnPassantMove\",value:function isEnPassantMove(py,px,y,x,type,team,boardState){if(\"pawn\"===type){var pawnDirection=\"our\"===team?1:-1;if(x-px===1||x-px===-1){if(py-y===1||py-y===-1){var enPassantAttackedPiece=boardState.find(function(p){return p.y===x&&p.x===y+pawnDirection&&p.enPassant;});if(enPassantAttackedPiece){return true;}}}}return false;}// py = initial y coordinate of the moving piece\n// px = initial x coordinate of the moving piece\n// y = y-coordinate of the place where we are moving the piece\n// x = x-coordinate of the place where we are moving the piece\n},{key:\"isValidMove\",value:function isValidMove(py,px,y,x,type,team,boardState,oppFlag){if(oppFlag===true){if(team===\"opponent\")return false;}if(px===x&&py===y)return false;if(type===\"pawn\"){var pawnRow=\"our\"===team?6:1;var pawnDirection=\"our\"===team?1:-1;//MOVEMENT LOGIC \nif(py===pawnRow){if(px===x&&(py-y===1*pawnDirection||py-y===2*pawnDirection)){var retVal=false;retVal=py-y===1*pawnDirection?!this.isTileOccupied(x,y,boardState):!this.isTileOccupied(x,y,boardState)&&!this.isTileOccupied(x,y+pawnDirection,boardState);return retVal;}else if(x-px===1||x-px===-1){if(py-y===1*pawnDirection){if(this.isTileOccupiedByOpponent(x,y,boardState,team))return true;}}}else if(x===px&&py-y===1*pawnDirection){return!this.isTileOccupied(x,y,boardState);}//ATTACKING LOGIC\nelse if(x-px===1||x-px===-1){if(/*py - y === 1 || py - y === -1*/py-y===1*pawnDirection){if(this.isTileOccupiedByOpponent(x,y,boardState,team))return true;}}}else if(type===\"knight\"){var knight_prospects=[[px+1,py-2],[px+1,py+2],[px+2,py-1],[px+2,py+1],[px-1,py-2],[px-1,py+2],[px-2,py-1],[px-2,py+1]];var flag=false;for(var i=0;i<=7;++i){var curr=knight_prospects[i];if(x===curr[0]&&y===curr[1]){flag=true;break;}}if(flag===false){return flag;}else{if(this.isTileOccupied(x,y,boardState)){if(this.isTileOccupiedByOpponent(x,y,boardState,team)){return true;}else return false;}else{return true;}}}else if(\"bishop\"===type){//move and attack logic for the bishop\n//check if the desired position is on a diagonal of the initial position.\nvar isTheMoveOnDiag=Math.abs(px-x)===Math.abs(py-y);if(!isTheMoveOnDiag)return false;else{var diagDir=[x-px>0?1:-1,y-py>0?1:-1];var _curr=[px+diagDir[0],py+diagDir[1]];// pieces present in between.\n// c is the number of squares in between.\nvar c=Math.abs(x-px)-1;//here we are checking whether the in-between pieces are  blockading or not \n//if they are bloakading then we deem the move invalid\nwhile(c--){if(this.isTileOccupied(_curr[0],_curr[1],boardState)){return false;}_curr[0]+=diagDir[0];_curr[1]+=diagDir[1];}if(this.isTileOccupied(x,y,boardState)&&!this.isTileOccupiedByOpponent(x,y,boardState,team)){return false;}return true;}}else if(\"rook\"===type){//move and attack logic for the rook\n// check if the desired position is on a horizontal or vertical file of the original position  \nvar isTheMoveOnSameFile=px===x||py===y;if(!isTheMoveOnSameFile)return false;else{var _curr2=[x===px?x:x>px?px+1:px-1,y===py?y:y>py?py+1:py-1];// pieces present in between.\n// c is the number of squares in between.\nvar _c=Math.max(Math.abs(x-px),Math.abs(y-py))-1;//here we are checking whether the in-between pieces are  blockading or not \n//if they are bloakading then we deem the move invalid\nwhile(_c--){if(this.isTileOccupied(_curr2[0],_curr2[1],boardState)){return false;}var a=_curr2[0],b=_curr2[1];_curr2[0]=x===px?a:x>px?a+1:a-1;_curr2[1]=y===py?b:y>py?b+1:b-1;}if(this.isTileOccupied(x,y,boardState)&&!this.isTileOccupiedByOpponent(x,y,boardState,team)){return false;}return true;}}else if(\"queen\"===type){//move and attack logic for the queen\n// check if the desired position is on a horizontal or vertical file or on one of the diagonals of the original position  \nvar _isTheMoveOnSameFile=px===x||py===y;var _isTheMoveOnDiag=Math.abs(px-x)===Math.abs(py-y);if(!(_isTheMoveOnSameFile||_isTheMoveOnDiag))return false;else{if(_isTheMoveOnDiag){var _diagDir=[x-px>0?1:-1,y-py>0?1:-1];var _curr3=[px+_diagDir[0],py+_diagDir[1]];// pieces present in between.\n// c is the number of squares in between.\nvar _c2=Math.abs(x-px)-1;//here we are checking whether the in-between pieces are  blockading or not \n//if they are bloakading then we deem the move invalid\nwhile(_c2--){if(this.isTileOccupied(_curr3[0],_curr3[1],boardState)){return false;}_curr3[0]+=_diagDir[0];_curr3[1]+=_diagDir[1];}if(this.isTileOccupied(x,y,boardState)&&!this.isTileOccupiedByOpponent(x,y,boardState,team)){return false;}return true;}else{var _curr4=[x===px?x:x>px?px+1:px-1,y===py?y:y>py?py+1:py-1];// pieces present in between.\n// c is the number of squares in between.\nvar _c3=Math.max(Math.abs(x-px),Math.abs(y-py))-1;//here we are checking whether the in-between pieces are  blockading or not \n//if they are bloakading then we deem the move invalid\nwhile(_c3--){if(this.isTileOccupied(_curr4[0],_curr4[1],boardState)){return false;}var _a=_curr4[0],_b=_curr4[1];_curr4[0]=x===px?_a:x>px?_a+1:_a-1;_curr4[1]=y===py?_b:y>py?_b+1:_b-1;}if(this.isTileOccupied(x,y,boardState)&&!this.isTileOccupiedByOpponent(x,y,boardState,team)){return false;}return true;}}}else if(\"king\"===type){var king_dir=[[px+1,py],[px,py+1],[px-1,py],[px,py-1],[px+1,py+1],[px+1,py-1],[px-1,py-1],[px-1,py+1]];var piece=king_dir.find(function(p){return p[0]===x&&p[1]===y;});if(piece){}else return false;if(this.isTileOccupied(x,y,boardState)&&!this.isTileOccupiedByOpponent(x,y,boardState,team)){return false;}return true;}return false;}}]);return Referee;}();export{Referee as default};","map":{"version":3,"names":["Referee","boardState","team","ret","count","i","length","piece","j","a","isValidMove","x","y","type","newBoardState","getBoardStateAfterMove","inCheck","oppteam","king","find","p","px","py","fy","fx","forEach","ele","newEle","push","pawnDirection","enPassantAttackedPiece","enPassant","oppFlag","pawnRow","retVal","isTileOccupied","isTileOccupiedByOpponent","knight_prospects","flag","curr","isTheMoveOnDiag","Math","abs","diagDir","c","isTheMoveOnSameFile","max","b","king_dir"],"sources":["C:/Users/think/Desktop/git_projects/chess_project/frontend/chess-frontend/src/Components/Referee.js"],"sourcesContent":["\r\nexport default class Referee {\r\n\r\n    /**\r\n     * \r\n     * @param {*} boardState given boardState at which we want to calculate checkmate\r\n     * @param {*} team the team whose turn it is\r\n     * @returns \r\n     */\r\n    isStaleMate(boardState, team) {\r\n        let ret = true;\r\n        let count = 0;\r\n        for (let i = 0; i < boardState.length; ++i) {\r\n            const piece = boardState[i];\r\n            if (piece.team === team) {\r\n                for (let i = 0; i <= 7; ++i) {\r\n                    for (let j = 0; j <= 7; j++) {\r\n                        const a = this.isValidMove(piece.x, piece.y, j, i, piece.type, piece.team, boardState,false);\r\n                        if (a) {\r\n                            const newBoardState = this.getBoardStateAfterMove(piece.x, piece.y, i, j, boardState);\r\n                            if (!this.inCheck(newBoardState, piece.team)) {\r\n                              count++;\r\n                            //   console.log(piece);\r\n                            }\r\n                        }\r\n                        if (count > 0) {\r\n                            ret = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (count > 0) {\r\n                        ret = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (count > 0) {\r\n                ret = false;\r\n                break;\r\n            }\r\n        }\r\n        // console.log(`count = ${count}`);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * given boardState and team we will calculate whether the given \"team\" is in checkmate or not\r\n        basically we want to calculate if the given \"team\" has any valid moves or not \r\n        if any one valid move is found (move can be anywhere on the board) then return false\r\n        else return true\r\n     * \r\n     * \r\n     * @param {*} boardState given boardState at which we want to calculate checkmate\r\n     * @param {*} team the team who is being checkmated\r\n     * @returns  true if checkmate , false otherwise\r\n     */\r\n    inCheckMate(boardState, team) {\r\n        let ret = true;\r\n        let count = 0;\r\n        for (let i = 0; i < boardState.length; ++i) {\r\n            const piece = boardState[i];\r\n            if (piece.team === team) {\r\n                for (let i = 0; i <= 7; ++i) {\r\n                    for (let j = 0; j <= 7; j++) {\r\n                        const a = this.isValidMove(piece.x, piece.y, j, i, piece.type, piece.team, boardState,false);\r\n                        if (a) {\r\n                            const newBoardState = this.getBoardStateAfterMove(piece.x, piece.y, i, j, boardState);\r\n                            if (!this.inCheck(newBoardState, piece.team)) {\r\n                              count++;\r\n                            //   console.log(piece);\r\n                            }\r\n                        }\r\n                        if (count > 0) {\r\n                            ret = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (count > 0) {\r\n                        ret = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (count > 0) {\r\n                ret = false;\r\n                break;\r\n            }\r\n        }\r\n        // console.log(`count = ${count}`);\r\n        return ret;\r\n    }\r\n    \r\n\r\n    /**\r\n     * \r\n     * @param {*} boardState state of board at which we want to check for \"CHECK\"\r\n     * @param {*} team the team whose king is in check is to be checked\r\n     * @returns \r\n     */\r\n    inCheck(boardState, team) {\r\n        const oppteam = (team === \"our\") ? \"opponent\" : \"our\";\r\n        const king = boardState.find((p) => (p.team === team && p.type === \"king\"));\r\n        if (!king) {\r\n            return false;\r\n        }\r\n        let ret = false;\r\n        for (let i = 0; i < boardState.length; ++i) {\r\n            const piece = boardState[i];\r\n            if (piece.team === oppteam) {\r\n                if (this.isValidMove(piece.x, piece.y, king.x, king.y, piece.type, piece.team, boardState,false)) {\r\n                    ret = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n\r\n    // if (referee.inCheck(referee.getBoardStateAfterMove(x, y, i, j, pieces), currentPiece.team, room, \"white\")) {\r\n    //     continue;\r\n    //   }\r\n    //   else{\r\n\r\n    /**\r\n     * \r\n     * @param {*} px  previous pos x\r\n     * @param {*} py previous pos y\r\n     * @param {*} fx final pos x\r\n     * @param {*} fy final pos y\r\n     * @param {*} boardState \r\n     * @returns  board state after move is made\r\n     */\r\n    getBoardStateAfterMove(px,py,fy,fx,boardState)\r\n    {\r\n        const ret = [];\r\n        // if there is a piece on (fx,fy) we need to delete it\r\n        boardState.forEach((ele) => {\r\n            if (ele.x === fx && ele.y === fy) {\r\n                // do nothing\r\n            }\r\n            else if (ele.x === px && ele.y === py) {\r\n                const newEle = {...ele};\r\n                newEle.y = fy; newEle.x = fx; ret.push(newEle);\r\n            }\r\n            else {\r\n                const newEle = {...ele};\r\n                ret.push(newEle);\r\n            }\r\n        })\r\n        return ret;\r\n    }\r\n\r\n    isTileOccupied(x, y, boardState) {\r\n        const piece = boardState.find((p) => (p.y === x && p.x === y));\r\n        if (piece) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    isTileOccupiedByOpponent(x, y, boardState, team) {\r\n        const piece = boardState.find((p) => (p.y === x && p.x === y && p.team !== team));\r\n        if (piece) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    isEnPassantMove(py, px, y, x, type, team, boardState) {\r\n        if (\"pawn\" === type) {\r\n            const pawnDirection = \"our\" === team ? 1 : -1;\r\n            if (x - px === 1 || x - px === -1) {\r\n                if (py - y === 1 || py - y === -1) {\r\n                    const enPassantAttackedPiece = boardState.find(p => ((p.y === x) && (p.x === y + pawnDirection) && p.enPassant));\r\n                    if (enPassantAttackedPiece) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // py = initial y coordinate of the moving piece\r\n    // px = initial x coordinate of the moving piece\r\n    // y = y-coordinate of the place where we are moving the piece\r\n    // x = x-coordinate of the place where we are moving the piece\r\n    isValidMove(py, px, y, x, type, team, boardState,oppFlag) {\r\n        if(oppFlag === true)\r\n        {\r\n            if(team === \"opponent\")\r\n            return false;\r\n        }\r\n\r\n        if (px === x && py === y)\r\n            return false;\r\n\r\n        if (type === \"pawn\") {\r\n            const pawnRow = ((\"our\" === team) ? 6 : 1);\r\n            const pawnDirection = ((\"our\" === team) ? 1 : -1);\r\n            //MOVEMENT LOGIC \r\n            if (py === pawnRow) {\r\n                if (px === x && ((py - y) === 1 * pawnDirection || (py - y) === 2 * pawnDirection)) {\r\n                    let retVal = false;\r\n                    retVal = (py - y) === 1 * pawnDirection ? (!this.isTileOccupied(x, y, boardState)) : ((!this.isTileOccupied(x, y, boardState)) && (!this.isTileOccupied(x, y + pawnDirection, boardState)));\r\n                    return retVal;\r\n                }\r\n                else if (x - px === 1 || x - px === -1) {\r\n                    if ((py - y )=== 1 * pawnDirection) {\r\n                        if (this.isTileOccupiedByOpponent(x, y, boardState, team))\r\n                            return true;\r\n                    }\r\n                }\r\n\r\n            }\r\n            else if (x === px && ((py - y) === 1 * pawnDirection)) {\r\n                return !this.isTileOccupied(x, y, boardState);\r\n            }\r\n            //ATTACKING LOGIC\r\n            else if (x - px === 1 || x - px === -1) {\r\n                if (/*py - y === 1 || py - y === -1*/ (py - y )=== 1 * pawnDirection) {\r\n                    if (this.isTileOccupiedByOpponent(x, y, boardState, team))\r\n                        return true;\r\n                }\r\n            }\r\n        }\r\n        else if (type === \"knight\") {\r\n            const knight_prospects = [[px + 1, py - 2], [px + 1, py + 2], [px + 2, py - 1], [px + 2, py + 1], [px - 1, py - 2], [px - 1, py + 2], [px - 2, py - 1], [px - 2, py + 1]];\r\n            let flag = false;\r\n            for (let i = 0; i <= 7; ++i) {\r\n                const curr = knight_prospects[i];\r\n                if ((x === curr[0] && y === curr[1])) {\r\n                    flag = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (flag === false) {\r\n                return flag;\r\n            }\r\n            else {\r\n                if (this.isTileOccupied(x, y, boardState)) {\r\n                    if (this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                        return true;\r\n                    }\r\n                    else\r\n                        return false;\r\n                }\r\n                else {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else if (\"bishop\" === type) {\r\n            //move and attack logic for the bishop\r\n            //check if the desired position is on a diagonal of the initial position.\r\n           \r\n            const isTheMoveOnDiag = (Math.abs(px - x) === Math.abs(py - y));\r\n            if (!isTheMoveOnDiag)\r\n                return false;\r\n            else {\r\n                const diagDir = [((x - px) > 0 ? 1 : -1), ((y - py) > 0 ? 1 : -1)];\r\n                let curr = [px + diagDir[0], py + diagDir[1]];\r\n                // pieces present in between.\r\n                // c is the number of squares in between.\r\n                let c = Math.abs(x - px) - 1;\r\n                //here we are checking whether the in-between pieces are  blockading or not \r\n                //if they are bloakading then we deem the move invalid\r\n                while (c--) {\r\n                    if (this.isTileOccupied(curr[0], curr[1], boardState)) {\r\n                        return false;\r\n                    }\r\n                    curr[0] += diagDir[0];\r\n                    curr[1] += diagDir[1];\r\n                }\r\n                if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n\r\n        }\r\n        else if (\"rook\" === type) {\r\n            //move and attack logic for the rook\r\n            // check if the desired position is on a horizontal or vertical file of the original position  \r\n            const isTheMoveOnSameFile = (px === x || py === y);\r\n            if (!isTheMoveOnSameFile)\r\n                return false;\r\n            else {\r\n                let curr = [(x === px ? x : ((x > px) ? px + 1 : px - 1)), (y === py ? y : ((y > py ? py + 1 : py - 1)))];\r\n                // pieces present in between.\r\n                // c is the number of squares in between.\r\n                let c = Math.max(Math.abs(x - px), Math.abs(y - py)) - 1;\r\n                //here we are checking whether the in-between pieces are  blockading or not \r\n                //if they are bloakading then we deem the move invalid\r\n                while (c--) {\r\n                    if (this.isTileOccupied(curr[0], curr[1], boardState)) {\r\n                        return false;\r\n                    }\r\n                    let a = curr[0], b = curr[1];\r\n                    curr[0] = (x === px ? a : ((x > px) ? a + 1 : a - 1));\r\n                    curr[1] = (y === py ? b : ((y > py) ? b + 1 : b - 1));\r\n                }\r\n                if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        else if (\"queen\" === type) {\r\n            //move and attack logic for the queen\r\n            // check if the desired position is on a horizontal or vertical file or on one of the diagonals of the original position  \r\n            const isTheMoveOnSameFile = ((px === x || py === y));\r\n            const isTheMoveOnDiag = (Math.abs(px - x) === Math.abs(py - y));\r\n            if (!(isTheMoveOnSameFile || isTheMoveOnDiag))\r\n                return false;\r\n            else {\r\n                if (isTheMoveOnDiag) {\r\n                    const diagDir = [((x - px) > 0 ? 1 : -1), ((y - py) > 0 ? 1 : -1)];\r\n                    let curr = [px + diagDir[0], py + diagDir[1]];\r\n                    // pieces present in between.\r\n                    // c is the number of squares in between.\r\n                    let c = Math.abs(x - px) - 1;\r\n                    //here we are checking whether the in-between pieces are  blockading or not \r\n                    //if they are bloakading then we deem the move invalid\r\n                    while (c--) {\r\n                        if (this.isTileOccupied(curr[0], curr[1], boardState)) {\r\n                            return false;\r\n                        }\r\n                        curr[0] += diagDir[0];\r\n                        curr[1] += diagDir[1];\r\n                    }\r\n                    if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                }\r\n                else {\r\n                    let curr = [(x === px ? x : ((x > px) ? px + 1 : px - 1)), (y === py ? y : ((y > py ? py + 1 : py - 1)))];\r\n                    // pieces present in between.\r\n                    // c is the number of squares in between.\r\n                    let c = Math.max(Math.abs(x - px), Math.abs(y - py)) - 1;\r\n                    //here we are checking whether the in-between pieces are  blockading or not \r\n                    //if they are bloakading then we deem the move invalid\r\n                    while (c--) {\r\n                        if (this.isTileOccupied(curr[0], curr[1], boardState)) {\r\n                            return false;\r\n                        }\r\n                        let a = curr[0], b = curr[1];\r\n                        curr[0] = (x === px ? a : ((x > px) ? a + 1 : a - 1));\r\n                        curr[1] = (y === py ? b : ((y > py) ? b + 1 : b - 1));\r\n                    }\r\n                    if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else if (\"king\" === type) {\r\n            const king_dir = [[px + 1, py], [px, py + 1], [px - 1, py], [px, py - 1], [px + 1, py + 1], [px + 1, py - 1], [px - 1, py - 1], [px - 1, py + 1]];\r\n            const piece = king_dir.find((p) => (p[0] === x && p[1] === y));\r\n            if (piece) {\r\n\r\n            }\r\n            else\r\n                return false;\r\n\r\n            if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                return false;\r\n            }\r\n            return true;\r\n\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}