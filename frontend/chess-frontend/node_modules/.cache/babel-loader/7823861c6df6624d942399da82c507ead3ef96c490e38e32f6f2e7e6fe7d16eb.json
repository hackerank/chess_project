{"ast":null,"code":"export default class Referee {\n  /**\r\n   * \r\n   * @param {*} boardState the boardState for which we want to check for \"CHECK\"\r\n   * @param {*} team the team whose king we want to check (\"our\" or \"opponent\")\r\n   * @param {*} room room from the gameboard component\r\n   * @param {*} color color from the gameboard component\r\n   * @returns true if in check otherwise false\r\n   */\n  async oppInCheck(boardState, room, color, piece) {\n    console.log(piece);\n    const king = boardState.find(p => p.team === \"opponent\" && p.type === \"king\");\n    if (!king) {\n      return false;\n    }\n    console.log(`king.x = ${king.x}`);\n    console.log(`king.y = ${king.y}`);\n    // console.log(this.isValidMove(piece.y,piece.x,king.x,king.y,piece.team,boardState,room,color));\n    for (let i = 0; i <= 7; ++i) {\n      for (let j = 0; j <= 7; j++) {\n        const a = await this.isValidMove(y, x, j, i, currentPiece.type, currentPiece.team, pieces, room, isBlackState ? currentPiece.team === \"our\" ? \"black\" : \"white\" : currentPiece.team === \"our\" ? \"white\" : \"black\");\n        if (a) {\n          dotsArr.push({\n            i: i,\n            j: j\n          });\n        }\n      }\n    }\n  }\n\n  // if (referee.inCheck(referee.getBoardStateAfterMove(x, y, i, j, pieces), currentPiece.team, room, \"white\")) {\n  //     continue;\n  //   }\n  //   else{\n\n  /**\r\n   * \r\n   * @param {*} px  previous pos x\r\n   * @param {*} py previous pos y\r\n   * @param {*} fx final pos x\r\n   * @param {*} fy final pos y\r\n   * @param {*} boardState \r\n   * @returns  board state after move is made\r\n   */\n  getBoardStateAfterMove(px, py, fy, fx, boardState) {\n    const ret = [];\n    // if there is a piece on (fx,fy) we need to delete it\n    boardState.forEach(ele => {\n      if (ele.x === fx && ele.y === fy) {\n        // do nothing\n      } else if (ele.x === px && ele.y === py) {\n        const newEle = {\n          ...ele\n        };\n        newEle.y = fy;\n        newEle.x = fx;\n        ret.push(newEle);\n      } else {\n        const newEle = {\n          ...ele\n        };\n        ret.push(newEle);\n      }\n    });\n    return ret;\n  }\n  isTileOccupied(x, y, boardState) {\n    const piece = boardState.find(p => p.y === x && p.x === y);\n    if (piece) {\n      return true;\n    }\n    return false;\n  }\n  isTileOccupiedByOpponent(x, y, boardState, team) {\n    const piece = boardState.find(p => p.y === x && p.x === y && p.team !== team);\n    if (piece) {\n      return true;\n    }\n    return false;\n  }\n  isEnPassantMove(py, px, y, x, type, team, boardState) {\n    if (\"pawn\" === type) {\n      const pawnDirection = \"our\" === team ? 1 : -1;\n      if (x - px === 1 || x - px === -1) {\n        if (py - y === 1 || py - y === -1) {\n          const enPassantAttackedPiece = boardState.find(p => p.y === x && p.x === y + pawnDirection && p.enPassant);\n          if (enPassantAttackedPiece) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // py = initial y coordinate of the moving piece\n  // px = initial x coordinate of the moving piece\n  // y = y-coordinate of the place where we are moving the piece\n  // x = x-coordinate of the place where we are moving the piece\n  async isValidMove(py, px, y, x, type, team, boardState, room, color) {\n    //     if (\"opponent\" === team)\n    //     return false;\n\n    // let ret = await fetch('http://192.168.29.13:8080/api/turn', {\n    //     method: \"POST\",\n    //     headers: {\n    //         \"Content-type\": \"application/json\",\n    //     },\n    //     body: room\n    // })\n    //     .then(response => response.json())\n    //     .then(data => {\n    //         if ((data[\"turn\"] == \"invalid\")) {\n    //             return false;\n    //         }\n    //         else if (data[\"turn\"] != color) {\n    //             return false;\n    //         }\n    //         else return true;\n    //     })\n    //     .catch(error => console.error('Error:', error));\n\n    // if (!ret)\n    // {\n    //     return false;\n    // }\n\n    if (px === x && py === y) return false;\n    if (type === \"pawn\") {\n      const pawnRow = \"our\" === team ? 6 : 1;\n      const pawnDirection = \"our\" === team ? 1 : -1;\n      //MOVEMENT LOGIC \n      if (py === pawnRow) {\n        if (px === x && (py - y === 1 * pawnDirection || py - y === 2 * pawnDirection)) {\n          let retVal = false;\n          retVal = py - y === 1 * pawnDirection ? !this.isTileOccupied(x, y, boardState) : !this.isTileOccupied(x, y, boardState) && !this.isTileOccupied(x, y + pawnDirection, boardState);\n          return retVal;\n        } else if (x - px === 1 || x - px === -1) {\n          if (py - y === 1 || py - y === -1) {\n            if (this.isTileOccupiedByOpponent(x, y, boardState, team)) return true;\n          }\n        }\n      } else if (x === px && py - y === 1 * pawnDirection) {\n        return !this.isTileOccupied(x, y, boardState);\n      }\n      //ATTACKING LOGIC\n      else if (x - px === 1 || x - px === -1) {\n        if (py - y === 1 || py - y === -1) {\n          if (this.isTileOccupiedByOpponent(x, y, boardState, team)) return true;\n        }\n      }\n    } else if (type === \"knight\") {\n      const knight_prospects = [[px + 1, py - 2], [px + 1, py + 2], [px + 2, py - 1], [px + 2, py + 1], [px - 1, py - 2], [px - 1, py + 2], [px - 2, py - 1], [px - 2, py + 1]];\n      let flag = false;\n      for (let i = 0; i <= 7; ++i) {\n        const curr = knight_prospects[i];\n        if (x === curr[0] && y === curr[1]) {\n          flag = true;\n          break;\n        }\n      }\n      if (flag === false) {\n        return flag;\n      } else {\n        if (this.isTileOccupied(x, y, boardState)) {\n          if (this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n            return true;\n          } else return false;\n        } else {\n          return true;\n        }\n      }\n    } else if (\"bishop\" === type) {\n      //move and attack logic for the bishop\n      //check if the desired position is on a diagonal of the initial position.\n\n      const isTheMoveOnDiag = Math.abs(px - x) === Math.abs(py - y);\n      if (!isTheMoveOnDiag) return false;else {\n        const diagDir = [x - px > 0 ? 1 : -1, y - py > 0 ? 1 : -1];\n        let curr = [px + diagDir[0], py + diagDir[1]];\n        // pieces present in between.\n        // c is the number of squares in between.\n        let c = Math.abs(x - px) - 1;\n        //here we are checking whether the in-between pieces are  blockading or not \n        //if they are bloakading then we deem the move invalid\n        while (c--) {\n          if (this.isTileOccupied(curr[0], curr[1], boardState)) {\n            return false;\n          }\n          curr[0] += diagDir[0];\n          curr[1] += diagDir[1];\n        }\n        if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n          return false;\n        }\n        return true;\n      }\n    } else if (\"rook\" === type) {\n      //move and attack logic for the rook\n      // check if the desired position is on a horizontal or vertical file of the original position  \n      const isTheMoveOnSameFile = px === x || py === y;\n      if (!isTheMoveOnSameFile) return false;else {\n        let curr = [x === px ? x : x > px ? px + 1 : px - 1, y === py ? y : y > py ? py + 1 : py - 1];\n        // pieces present in between.\n        // c is the number of squares in between.\n        let c = Math.max(Math.abs(x - px), Math.abs(y - py)) - 1;\n        //here we are checking whether the in-between pieces are  blockading or not \n        //if they are bloakading then we deem the move invalid\n        while (c--) {\n          if (this.isTileOccupied(curr[0], curr[1], boardState)) {\n            return false;\n          }\n          let a = curr[0],\n            b = curr[1];\n          curr[0] = x === px ? a : x > px ? a + 1 : a - 1;\n          curr[1] = y === py ? b : y > py ? b + 1 : b - 1;\n        }\n        if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n          return false;\n        }\n        return true;\n      }\n    } else if (\"queen\" === type) {\n      //move and attack logic for the queen\n      // check if the desired position is on a horizontal or vertical file or on one of the diagonals of the original position  \n      const isTheMoveOnSameFile = px === x || py === y;\n      const isTheMoveOnDiag = Math.abs(px - x) === Math.abs(py - y);\n      if (!(isTheMoveOnSameFile || isTheMoveOnDiag)) return false;else {\n        if (isTheMoveOnDiag) {\n          const diagDir = [x - px > 0 ? 1 : -1, y - py > 0 ? 1 : -1];\n          let curr = [px + diagDir[0], py + diagDir[1]];\n          // pieces present in between.\n          // c is the number of squares in between.\n          let c = Math.abs(x - px) - 1;\n          //here we are checking whether the in-between pieces are  blockading or not \n          //if they are bloakading then we deem the move invalid\n          while (c--) {\n            if (this.isTileOccupied(curr[0], curr[1], boardState)) {\n              return false;\n            }\n            curr[0] += diagDir[0];\n            curr[1] += diagDir[1];\n          }\n          if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n            return false;\n          }\n          return true;\n        } else {\n          let curr = [x === px ? x : x > px ? px + 1 : px - 1, y === py ? y : y > py ? py + 1 : py - 1];\n          // pieces present in between.\n          // c is the number of squares in between.\n          let c = Math.max(Math.abs(x - px), Math.abs(y - py)) - 1;\n          //here we are checking whether the in-between pieces are  blockading or not \n          //if they are bloakading then we deem the move invalid\n          while (c--) {\n            if (this.isTileOccupied(curr[0], curr[1], boardState)) {\n              return false;\n            }\n            let a = curr[0],\n              b = curr[1];\n            curr[0] = x === px ? a : x > px ? a + 1 : a - 1;\n            curr[1] = y === py ? b : y > py ? b + 1 : b - 1;\n          }\n          if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n            return false;\n          }\n          return true;\n        }\n      }\n    } else if (\"king\" === type) {\n      const king_dir = [[px + 1, py], [px, py + 1], [px - 1, py], [px, py - 1], [px + 1, py + 1], [px + 1, py - 1], [px - 1, py - 1], [px - 1, py + 1]];\n      const piece = king_dir.find(p => p[0] === x && p[1] === y);\n      if (piece) {} else return false;\n      if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n}","map":{"version":3,"names":["Referee","oppInCheck","boardState","room","color","piece","console","log","king","find","p","team","type","x","y","i","j","a","isValidMove","currentPiece","pieces","isBlackState","dotsArr","push","getBoardStateAfterMove","px","py","fy","fx","ret","forEach","ele","newEle","isTileOccupied","isTileOccupiedByOpponent","isEnPassantMove","pawnDirection","enPassantAttackedPiece","enPassant","pawnRow","retVal","knight_prospects","flag","curr","isTheMoveOnDiag","Math","abs","diagDir","c","isTheMoveOnSameFile","max","b","king_dir"],"sources":["C:/Users/think/Desktop/Projects/Chess Project/frontend/chess-frontend/src/Components/Referee.js"],"sourcesContent":["\r\nexport default class Referee {\r\n\r\n    /**\r\n     * \r\n     * @param {*} boardState the boardState for which we want to check for \"CHECK\"\r\n     * @param {*} team the team whose king we want to check (\"our\" or \"opponent\")\r\n     * @param {*} room room from the gameboard component\r\n     * @param {*} color color from the gameboard component\r\n     * @returns true if in check otherwise false\r\n     */\r\n    async oppInCheck(boardState,room,color,piece) {\r\n        console.log(piece);\r\n        const king = boardState.find((p) => (p.team === \"opponent\" && p.type === \"king\"));\r\n        if (!king) {\r\n            return false;\r\n        }\r\n        console.log(`king.x = ${king.x}`);\r\n        console.log(`king.y = ${king.y}`);\r\n        // console.log(this.isValidMove(piece.y,piece.x,king.x,king.y,piece.team,boardState,room,color));\r\n        for (let i = 0; i <= 7; ++i) {\r\n            for (let j = 0; j <= 7; j++) {\r\n                const a = await this.isValidMove(y, x, j, i, currentPiece.type, currentPiece.team, pieces, room, (isBlackState) ? ((currentPiece.team === \"our\" ? \"black\" : \"white\")) : (currentPiece.team === \"our\" ? \"white\" : \"black\"));\r\n                if (a) {\r\n                  dotsArr.push({ i: i, j: j });\r\n                }\r\n            }\r\n          }\r\n\r\n    }\r\n\r\n    // if (referee.inCheck(referee.getBoardStateAfterMove(x, y, i, j, pieces), currentPiece.team, room, \"white\")) {\r\n    //     continue;\r\n    //   }\r\n    //   else{\r\n\r\n    /**\r\n     * \r\n     * @param {*} px  previous pos x\r\n     * @param {*} py previous pos y\r\n     * @param {*} fx final pos x\r\n     * @param {*} fy final pos y\r\n     * @param {*} boardState \r\n     * @returns  board state after move is made\r\n     */\r\n    getBoardStateAfterMove(px,py,fy,fx,boardState)\r\n    {\r\n        const ret = [];\r\n        // if there is a piece on (fx,fy) we need to delete it\r\n        boardState.forEach((ele) => {\r\n            if (ele.x === fx && ele.y === fy) {\r\n                // do nothing\r\n            }\r\n            else if (ele.x === px && ele.y === py) {\r\n                const newEle = {...ele};\r\n                newEle.y = fy; newEle.x = fx; ret.push(newEle);\r\n            }\r\n            else {\r\n                const newEle = {...ele};\r\n                ret.push(newEle);\r\n            }\r\n        })\r\n        return ret;\r\n    }\r\n\r\n    isTileOccupied(x, y, boardState) {\r\n        const piece = boardState.find((p) => (p.y === x && p.x === y));\r\n        if (piece) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    isTileOccupiedByOpponent(x, y, boardState, team) {\r\n        const piece = boardState.find((p) => (p.y === x && p.x === y && p.team !== team));\r\n        if (piece) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    isEnPassantMove(py, px, y, x, type, team, boardState) {\r\n        if (\"pawn\" === type) {\r\n            const pawnDirection = \"our\" === team ? 1 : -1;\r\n            if (x - px === 1 || x - px === -1) {\r\n                if (py - y === 1 || py - y === -1) {\r\n                    const enPassantAttackedPiece = boardState.find(p => ((p.y === x) && (p.x === y + pawnDirection) && p.enPassant));\r\n                    if (enPassantAttackedPiece) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // py = initial y coordinate of the moving piece\r\n    // px = initial x coordinate of the moving piece\r\n    // y = y-coordinate of the place where we are moving the piece\r\n    // x = x-coordinate of the place where we are moving the piece\r\n    async isValidMove(py, px, y, x, type, team, boardState, room, color) {\r\n\r\n\r\n\r\n        //     if (\"opponent\" === team)\r\n        //     return false;\r\n\r\n        // let ret = await fetch('http://192.168.29.13:8080/api/turn', {\r\n        //     method: \"POST\",\r\n        //     headers: {\r\n        //         \"Content-type\": \"application/json\",\r\n        //     },\r\n        //     body: room\r\n        // })\r\n        //     .then(response => response.json())\r\n        //     .then(data => {\r\n        //         if ((data[\"turn\"] == \"invalid\")) {\r\n        //             return false;\r\n        //         }\r\n        //         else if (data[\"turn\"] != color) {\r\n        //             return false;\r\n        //         }\r\n        //         else return true;\r\n        //     })\r\n        //     .catch(error => console.error('Error:', error));\r\n\r\n        // if (!ret)\r\n        // {\r\n        //     return false;\r\n        // }\r\n\r\n        if (px === x && py === y)\r\n            return false;\r\n\r\n        if (type === \"pawn\") {\r\n            const pawnRow = ((\"our\" === team) ? 6 : 1);\r\n            const pawnDirection = ((\"our\" === team) ? 1 : -1);\r\n            //MOVEMENT LOGIC \r\n            if (py === pawnRow) {\r\n                if (px === x && ((py - y) === 1 * pawnDirection || (py - y) === 2 * pawnDirection)) {\r\n                    let retVal = false;\r\n                    retVal = (py - y) === 1 * pawnDirection ? (!this.isTileOccupied(x, y, boardState)) : ((!this.isTileOccupied(x, y, boardState)) && (!this.isTileOccupied(x, y + pawnDirection, boardState)));\r\n                    return retVal;\r\n                }\r\n                else if (x - px === 1 || x - px === -1) {\r\n                    if (py - y === 1 || py - y === -1) {\r\n                        if (this.isTileOccupiedByOpponent(x, y, boardState, team))\r\n                            return true;\r\n                    }\r\n                }\r\n\r\n            }\r\n            else if (x === px && ((py - y) === 1 * pawnDirection)) {\r\n                return !this.isTileOccupied(x, y, boardState);\r\n            }\r\n            //ATTACKING LOGIC\r\n            else if (x - px === 1 || x - px === -1) {\r\n                if (py - y === 1 || py - y === -1) {\r\n                    if (this.isTileOccupiedByOpponent(x, y, boardState, team))\r\n                        return true;\r\n                }\r\n            }\r\n        }\r\n        else if (type === \"knight\") {\r\n            const knight_prospects = [[px + 1, py - 2], [px + 1, py + 2], [px + 2, py - 1], [px + 2, py + 1], [px - 1, py - 2], [px - 1, py + 2], [px - 2, py - 1], [px - 2, py + 1]];\r\n            let flag = false;\r\n            for (let i = 0; i <= 7; ++i) {\r\n                const curr = knight_prospects[i];\r\n                if ((x === curr[0] && y === curr[1])) {\r\n                    flag = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (flag === false) {\r\n                return flag;\r\n            }\r\n            else {\r\n                if (this.isTileOccupied(x, y, boardState)) {\r\n                    if (this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                        return true;\r\n                    }\r\n                    else\r\n                        return false;\r\n                }\r\n                else {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else if (\"bishop\" === type) {\r\n            //move and attack logic for the bishop\r\n            //check if the desired position is on a diagonal of the initial position.\r\n           \r\n            const isTheMoveOnDiag = (Math.abs(px - x) === Math.abs(py - y));\r\n            if (!isTheMoveOnDiag)\r\n                return false;\r\n            else {\r\n                const diagDir = [((x - px) > 0 ? 1 : -1), ((y - py) > 0 ? 1 : -1)];\r\n                let curr = [px + diagDir[0], py + diagDir[1]];\r\n                // pieces present in between.\r\n                // c is the number of squares in between.\r\n                let c = Math.abs(x - px) - 1;\r\n                //here we are checking whether the in-between pieces are  blockading or not \r\n                //if they are bloakading then we deem the move invalid\r\n                while (c--) {\r\n                    if (this.isTileOccupied(curr[0], curr[1], boardState)) {\r\n                        return false;\r\n                    }\r\n                    curr[0] += diagDir[0];\r\n                    curr[1] += diagDir[1];\r\n                }\r\n                if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n\r\n        }\r\n        else if (\"rook\" === type) {\r\n            //move and attack logic for the rook\r\n            // check if the desired position is on a horizontal or vertical file of the original position  \r\n            const isTheMoveOnSameFile = (px === x || py === y);\r\n            if (!isTheMoveOnSameFile)\r\n                return false;\r\n            else {\r\n                let curr = [(x === px ? x : ((x > px) ? px + 1 : px - 1)), (y === py ? y : ((y > py ? py + 1 : py - 1)))];\r\n                // pieces present in between.\r\n                // c is the number of squares in between.\r\n                let c = Math.max(Math.abs(x - px), Math.abs(y - py)) - 1;\r\n                //here we are checking whether the in-between pieces are  blockading or not \r\n                //if they are bloakading then we deem the move invalid\r\n                while (c--) {\r\n                    if (this.isTileOccupied(curr[0], curr[1], boardState)) {\r\n                        return false;\r\n                    }\r\n                    let a = curr[0], b = curr[1];\r\n                    curr[0] = (x === px ? a : ((x > px) ? a + 1 : a - 1));\r\n                    curr[1] = (y === py ? b : ((y > py) ? b + 1 : b - 1));\r\n                }\r\n                if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        else if (\"queen\" === type) {\r\n            //move and attack logic for the queen\r\n            // check if the desired position is on a horizontal or vertical file or on one of the diagonals of the original position  \r\n            const isTheMoveOnSameFile = ((px === x || py === y));\r\n            const isTheMoveOnDiag = (Math.abs(px - x) === Math.abs(py - y));\r\n            if (!(isTheMoveOnSameFile || isTheMoveOnDiag))\r\n                return false;\r\n            else {\r\n                if (isTheMoveOnDiag) {\r\n                    const diagDir = [((x - px) > 0 ? 1 : -1), ((y - py) > 0 ? 1 : -1)];\r\n                    let curr = [px + diagDir[0], py + diagDir[1]];\r\n                    // pieces present in between.\r\n                    // c is the number of squares in between.\r\n                    let c = Math.abs(x - px) - 1;\r\n                    //here we are checking whether the in-between pieces are  blockading or not \r\n                    //if they are bloakading then we deem the move invalid\r\n                    while (c--) {\r\n                        if (this.isTileOccupied(curr[0], curr[1], boardState)) {\r\n                            return false;\r\n                        }\r\n                        curr[0] += diagDir[0];\r\n                        curr[1] += diagDir[1];\r\n                    }\r\n                    if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                }\r\n                else {\r\n                    let curr = [(x === px ? x : ((x > px) ? px + 1 : px - 1)), (y === py ? y : ((y > py ? py + 1 : py - 1)))];\r\n                    // pieces present in between.\r\n                    // c is the number of squares in between.\r\n                    let c = Math.max(Math.abs(x - px), Math.abs(y - py)) - 1;\r\n                    //here we are checking whether the in-between pieces are  blockading or not \r\n                    //if they are bloakading then we deem the move invalid\r\n                    while (c--) {\r\n                        if (this.isTileOccupied(curr[0], curr[1], boardState)) {\r\n                            return false;\r\n                        }\r\n                        let a = curr[0], b = curr[1];\r\n                        curr[0] = (x === px ? a : ((x > px) ? a + 1 : a - 1));\r\n                        curr[1] = (y === py ? b : ((y > py) ? b + 1 : b - 1));\r\n                    }\r\n                    if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else if (\"king\" === type) {\r\n            const king_dir = [[px + 1, py], [px, py + 1], [px - 1, py], [px, py - 1], [px + 1, py + 1], [px + 1, py - 1], [px - 1, py - 1], [px - 1, py + 1]];\r\n            const piece = king_dir.find((p) => (p[0] === x && p[1] === y));\r\n            if (piece) {\r\n\r\n            }\r\n            else\r\n                return false;\r\n\r\n            if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                return false;\r\n            }\r\n            return true;\r\n\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}