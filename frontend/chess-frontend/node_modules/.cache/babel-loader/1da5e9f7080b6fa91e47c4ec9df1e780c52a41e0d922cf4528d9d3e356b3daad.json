{"ast":null,"code":"export default class Referee {\n  /**\r\n   * \r\n   * @param {*} boardState given boardState at which we want to calculate checkmate\r\n   * @param {*} team the team whose turn it is\r\n   * @returns \r\n   */\n  isStaleMate(boardState, team) {\n    let ret = true;\n    let count = 0;\n    for (let i = 0; i < boardState.length; ++i) {\n      const piece = boardState[i];\n      if (piece.team === team) {\n        for (let i = 0; i <= 7; ++i) {\n          for (let j = 0; j <= 7; j++) {\n            const a = this.isValidMove(piece.x, piece.y, j, i, piece.type, piece.team, boardState, false);\n            if (a) {\n              const newBoardState = this.getBoardStateAfterMove(piece.x, piece.y, i, j, boardState);\n              if (!this.inCheck(newBoardState, piece.team)) {\n                count++;\n                //   console.log(piece);\n              }\n            }\n\n            if (count > 0) {\n              ret = false;\n              break;\n            }\n          }\n          if (count > 0) {\n            ret = false;\n            break;\n          }\n        }\n      }\n      if (count > 0) {\n        ret = false;\n        break;\n      }\n    }\n    // console.log(`count = ${count}`);\n    return ret;\n  }\n\n  /**\r\n   * given boardState and team we will calculate whether the given \"team\" is in checkmate or not\r\n      basically we want to calculate if the given \"team\" has any valid moves or not \r\n      if any one valid move is found (move can be anywhere on the board) then return false\r\n      else return true\r\n   * \r\n   * \r\n   * @param {*} boardState given boardState at which we want to calculate checkmate\r\n   * @param {*} team the team who is being checkmated\r\n   * @returns  true if checkmate , false otherwise\r\n   */\n  inCheckMate(boardState, team) {\n    let ret = true;\n    let count = 0;\n    for (let i = 0; i < boardState.length; ++i) {\n      const piece = boardState[i];\n      if (piece.team === team) {\n        for (let i = 0; i <= 7; ++i) {\n          for (let j = 0; j <= 7; j++) {\n            const a = this.isValidMove(piece.x, piece.y, j, i, piece.type, piece.team, boardState, false);\n            if (a) {\n              const newBoardState = this.getBoardStateAfterMove(piece.x, piece.y, i, j, boardState);\n              if (!this.inCheck(newBoardState, piece.team)) {\n                count++;\n                //   console.log(piece);\n              }\n            }\n\n            if (count > 0) {\n              ret = false;\n              break;\n            }\n          }\n          if (count > 0) {\n            ret = false;\n            break;\n          }\n        }\n      }\n      if (count > 0) {\n        ret = false;\n        break;\n      }\n    }\n    // console.log(`count = ${count}`);\n    return ret;\n  }\n\n  /**\r\n   * \r\n   * @param {*} boardState state of board at which we want to check for \"CHECK\"\r\n   * @param {*} team the team whose king is in check is to be checked\r\n   * @returns \r\n   */\n  inCheck(boardState, team) {\n    const oppteam = team === \"our\" ? \"opponent\" : \"our\";\n    const king = boardState.find(p => p.team === team && p.type === \"king\");\n    console.log(king);\n    if (!king) {\n      return false;\n    }\n    let ret = false;\n    for (let i = 0; i < boardState.length; ++i) {\n      const piece = boardState[i];\n      if (piece.team === oppteam && piece.type === \"queen\")\n        // console.log(piece);\n        if (piece.team === oppteam) {\n          if (this.isValidMove(piece.x, piece.y, king.x, king.y, piece.type, piece.team, boardState, false)) {\n            if (ret === true) ret = true;\n            break;\n          }\n        }\n    }\n    return ret;\n  }\n\n  // if (referee.inCheck(referee.getBoardStateAfterMove(x, y, i, j, pieces), currentPiece.team, room, \"white\")) {\n  //     continue;\n  //   }\n  //   else{\n\n  /**\r\n   * \r\n   * @param {*} px  previous pos x\r\n   * @param {*} py previous pos y\r\n   * @param {*} fx final pos x\r\n   * @param {*} fy final pos y\r\n   * @param {*} boardState \r\n   * @returns  board state after move is made\r\n   */\n  getBoardStateAfterMove(px, py, fy, fx, boardState) {\n    const ret = [];\n    // if there is a piece on (fx,fy) we need to delete it\n    boardState.forEach(ele => {\n      if (ele.x === fx && ele.y === fy) {\n        // do nothing\n      } else if (ele.x === px && ele.y === py) {\n        const newEle = {\n          ...ele\n        };\n        newEle.y = fy;\n        newEle.x = fx;\n        ret.push(newEle);\n      } else {\n        const newEle = {\n          ...ele\n        };\n        ret.push(newEle);\n      }\n    });\n    return ret;\n  }\n  isTileOccupied(x, y, boardState) {\n    const piece = boardState.find(p => p.y === x && p.x === y);\n    if (piece) {\n      return true;\n    }\n    return false;\n  }\n  isTileOccupiedByOpponent(x, y, boardState, team) {\n    const piece = boardState.find(p => p.y === x && p.x === y && p.team !== team);\n    if (piece) {\n      return true;\n    }\n    return false;\n  }\n  isEnPassantMove(py, px, y, x, type, team, boardState) {\n    if (\"pawn\" === type) {\n      const pawnDirection = \"our\" === team ? 1 : -1;\n      if (x - px === 1 || x - px === -1) {\n        if (py - y === 1 || py - y === -1) {\n          const enPassantAttackedPiece = boardState.find(p => p.y === x && p.x === y + pawnDirection && p.enPassant);\n          if (enPassantAttackedPiece) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // py = initial y coordinate of the moving piece\n  // px = initial x coordinate of the moving piece\n  // y = y-coordinate of the place where we are moving the piece\n  // x = x-coordinate of the place where we are moving the piece\n  isValidMove(py, px, y, x, type, team, boardState, oppFlag) {\n    if (oppFlag) {\n      if (team === \"opponent\") return false;\n    }\n    if (px === x && py === y) return false;\n    if (type === \"pawn\") {\n      const pawnRow = \"our\" === team ? 6 : 1;\n      const pawnDirection = \"our\" === team ? 1 : -1;\n      //MOVEMENT LOGIC \n      if (py === pawnRow) {\n        if (px === x && (py - y === 1 * pawnDirection || py - y === 2 * pawnDirection)) {\n          let retVal = false;\n          retVal = py - y === 1 * pawnDirection ? !this.isTileOccupied(x, y, boardState) : !this.isTileOccupied(x, y, boardState) && !this.isTileOccupied(x, y + pawnDirection, boardState);\n          return retVal;\n        } else if (x - px === 1 || x - px === -1) {\n          if (py - y === 1 || py - y === -1) {\n            if (this.isTileOccupiedByOpponent(x, y, boardState, team)) return true;\n          }\n        }\n      } else if (x === px && py - y === 1 * pawnDirection) {\n        return !this.isTileOccupied(x, y, boardState);\n      }\n      //ATTACKING LOGIC\n      else if (x - px === 1 || x - px === -1) {\n        if ( /*py - y === 1 || py - y === -1*/py - y === 1 * pawnDirection) {\n          if (this.isTileOccupiedByOpponent(x, y, boardState, team)) return true;\n        }\n      }\n    } else if (type === \"knight\") {\n      const knight_prospects = [[px + 1, py - 2], [px + 1, py + 2], [px + 2, py - 1], [px + 2, py + 1], [px - 1, py - 2], [px - 1, py + 2], [px - 2, py - 1], [px - 2, py + 1]];\n      let flag = false;\n      for (let i = 0; i <= 7; ++i) {\n        const curr = knight_prospects[i];\n        if (x === curr[0] && y === curr[1]) {\n          flag = true;\n          break;\n        }\n      }\n      if (flag === false) {\n        return flag;\n      } else {\n        if (this.isTileOccupied(x, y, boardState)) {\n          if (this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n            return true;\n          } else return false;\n        } else {\n          return true;\n        }\n      }\n    } else if (\"bishop\" === type) {\n      //move and attack logic for the bishop\n      //check if the desired position is on a diagonal of the initial position.\n\n      const isTheMoveOnDiag = Math.abs(px - x) === Math.abs(py - y);\n      if (!isTheMoveOnDiag) return false;else {\n        const diagDir = [x - px > 0 ? 1 : -1, y - py > 0 ? 1 : -1];\n        let curr = [px + diagDir[0], py + diagDir[1]];\n        // pieces present in between.\n        // c is the number of squares in between.\n        let c = Math.abs(x - px) - 1;\n        //here we are checking whether the in-between pieces are  blockading or not \n        //if they are bloakading then we deem the move invalid\n        while (c--) {\n          if (this.isTileOccupied(curr[0], curr[1], boardState)) {\n            return false;\n          }\n          curr[0] += diagDir[0];\n          curr[1] += diagDir[1];\n        }\n        if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n          return false;\n        }\n        return true;\n      }\n    } else if (\"rook\" === type) {\n      //move and attack logic for the rook\n      // check if the desired position is on a horizontal or vertical file of the original position  \n      const isTheMoveOnSameFile = px === x || py === y;\n      if (!isTheMoveOnSameFile) return false;else {\n        let curr = [x === px ? x : x > px ? px + 1 : px - 1, y === py ? y : y > py ? py + 1 : py - 1];\n        // pieces present in between.\n        // c is the number of squares in between.\n        let c = Math.max(Math.abs(x - px), Math.abs(y - py)) - 1;\n        //here we are checking whether the in-between pieces are  blockading or not \n        //if they are bloakading then we deem the move invalid\n        while (c--) {\n          if (this.isTileOccupied(curr[0], curr[1], boardState)) {\n            return false;\n          }\n          let a = curr[0],\n            b = curr[1];\n          curr[0] = x === px ? a : x > px ? a + 1 : a - 1;\n          curr[1] = y === py ? b : y > py ? b + 1 : b - 1;\n        }\n        if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n          return false;\n        }\n        return true;\n      }\n    } else if (\"queen\" === type) {\n      //move and attack logic for the queen\n      // check if the desired position is on a horizontal or vertical file or on one of the diagonals of the original position  \n      const isTheMoveOnSameFile = px === x || py === y;\n      const isTheMoveOnDiag = Math.abs(px - x) === Math.abs(py - y);\n      if (!(isTheMoveOnSameFile || isTheMoveOnDiag)) return false;else {\n        if (isTheMoveOnDiag) {\n          const diagDir = [x - px > 0 ? 1 : -1, y - py > 0 ? 1 : -1];\n          let curr = [px + diagDir[0], py + diagDir[1]];\n          // pieces present in between.\n          // c is the number of squares in between.\n          let c = Math.abs(x - px) - 1;\n          //here we are checking whether the in-between pieces are  blockading or not \n          //if they are bloakading then we deem the move invalid\n          while (c--) {\n            if (this.isTileOccupied(curr[0], curr[1], boardState)) {\n              return false;\n            }\n            curr[0] += diagDir[0];\n            curr[1] += diagDir[1];\n          }\n          if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n            return false;\n          }\n          return true;\n        } else {\n          let curr = [x === px ? x : x > px ? px + 1 : px - 1, y === py ? y : y > py ? py + 1 : py - 1];\n          // pieces present in between.\n          // c is the number of squares in between.\n          let c = Math.max(Math.abs(x - px), Math.abs(y - py)) - 1;\n          //here we are checking whether the in-between pieces are  blockading or not \n          //if they are bloakading then we deem the move invalid\n          while (c--) {\n            if (this.isTileOccupied(curr[0], curr[1], boardState)) {\n              return false;\n            }\n            let a = curr[0],\n              b = curr[1];\n            curr[0] = x === px ? a : x > px ? a + 1 : a - 1;\n            curr[1] = y === py ? b : y > py ? b + 1 : b - 1;\n          }\n          if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n            return false;\n          }\n          return true;\n        }\n      }\n    } else if (\"king\" === type) {\n      const king_dir = [[px + 1, py], [px, py + 1], [px - 1, py], [px, py - 1], [px + 1, py + 1], [px + 1, py - 1], [px - 1, py - 1], [px - 1, py + 1]];\n      const piece = king_dir.find(p => p[0] === x && p[1] === y);\n      if (piece) {} else return false;\n      if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  }\n}","map":{"version":3,"names":["Referee","isStaleMate","boardState","team","ret","count","i","length","piece","j","a","isValidMove","x","y","type","newBoardState","getBoardStateAfterMove","inCheck","inCheckMate","oppteam","king","find","p","console","log","px","py","fy","fx","forEach","ele","newEle","push","isTileOccupied","isTileOccupiedByOpponent","isEnPassantMove","pawnDirection","enPassantAttackedPiece","enPassant","oppFlag","pawnRow","retVal","knight_prospects","flag","curr","isTheMoveOnDiag","Math","abs","diagDir","c","isTheMoveOnSameFile","max","b","king_dir"],"sources":["C:/Users/think/Desktop/Projects/Chess Project/frontend/chess-frontend/src/Components/Referee.js"],"sourcesContent":["\r\nexport default class Referee {\r\n\r\n    /**\r\n     * \r\n     * @param {*} boardState given boardState at which we want to calculate checkmate\r\n     * @param {*} team the team whose turn it is\r\n     * @returns \r\n     */\r\n    isStaleMate(boardState, team) {\r\n        let ret = true;\r\n        let count = 0;\r\n        for (let i = 0; i < boardState.length; ++i) {\r\n            const piece = boardState[i];\r\n            if (piece.team === team) {\r\n                for (let i = 0; i <= 7; ++i) {\r\n                    for (let j = 0; j <= 7; j++) {\r\n                        const a = this.isValidMove(piece.x, piece.y, j, i, piece.type, piece.team, boardState,false);\r\n                        if (a) {\r\n                            const newBoardState = this.getBoardStateAfterMove(piece.x, piece.y, i, j, boardState);\r\n                            if (!this.inCheck(newBoardState, piece.team)) {\r\n                              count++;\r\n                            //   console.log(piece);\r\n                            }\r\n                        }\r\n                        if (count > 0) {\r\n                            ret = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (count > 0) {\r\n                        ret = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (count > 0) {\r\n                ret = false;\r\n                break;\r\n            }\r\n        }\r\n        // console.log(`count = ${count}`);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * given boardState and team we will calculate whether the given \"team\" is in checkmate or not\r\n        basically we want to calculate if the given \"team\" has any valid moves or not \r\n        if any one valid move is found (move can be anywhere on the board) then return false\r\n        else return true\r\n     * \r\n     * \r\n     * @param {*} boardState given boardState at which we want to calculate checkmate\r\n     * @param {*} team the team who is being checkmated\r\n     * @returns  true if checkmate , false otherwise\r\n     */\r\n    inCheckMate(boardState, team) {\r\n        let ret = true;\r\n        let count = 0;\r\n        for (let i = 0; i < boardState.length; ++i) {\r\n            const piece = boardState[i];\r\n            if (piece.team === team) {\r\n                for (let i = 0; i <= 7; ++i) {\r\n                    for (let j = 0; j <= 7; j++) {\r\n                        const a = this.isValidMove(piece.x, piece.y, j, i, piece.type, piece.team, boardState,false);\r\n                        if (a) {\r\n                            const newBoardState = this.getBoardStateAfterMove(piece.x, piece.y, i, j, boardState);\r\n                            if (!this.inCheck(newBoardState, piece.team)) {\r\n                              count++;\r\n                            //   console.log(piece);\r\n                            }\r\n                        }\r\n                        if (count > 0) {\r\n                            ret = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (count > 0) {\r\n                        ret = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (count > 0) {\r\n                ret = false;\r\n                break;\r\n            }\r\n        }\r\n        // console.log(`count = ${count}`);\r\n        return ret;\r\n    }\r\n    \r\n\r\n    /**\r\n     * \r\n     * @param {*} boardState state of board at which we want to check for \"CHECK\"\r\n     * @param {*} team the team whose king is in check is to be checked\r\n     * @returns \r\n     */\r\n    inCheck(boardState, team) {\r\n        const oppteam = (team === \"our\") ? \"opponent\" : \"our\";\r\n        const king = boardState.find((p) => (p.team === team && p.type === \"king\"));\r\n        console.log(king);\r\n        if (!king) {\r\n            return false;\r\n        }\r\n        let ret = false;\r\n        for (let i = 0; i < boardState.length; ++i) {\r\n            const piece = boardState[i];\r\n            if (piece.team === oppteam && piece.type === \"queen\")\r\n            // console.log(piece);\r\n            if (piece.team === oppteam) {\r\n                if (this.isValidMove(piece.x, piece.y, king.x, king.y, piece.type, piece.team, boardState,false)) {\r\n                    if(ret === true)\r\n                    ret = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n\r\n    // if (referee.inCheck(referee.getBoardStateAfterMove(x, y, i, j, pieces), currentPiece.team, room, \"white\")) {\r\n    //     continue;\r\n    //   }\r\n    //   else{\r\n\r\n    /**\r\n     * \r\n     * @param {*} px  previous pos x\r\n     * @param {*} py previous pos y\r\n     * @param {*} fx final pos x\r\n     * @param {*} fy final pos y\r\n     * @param {*} boardState \r\n     * @returns  board state after move is made\r\n     */\r\n    getBoardStateAfterMove(px,py,fy,fx,boardState)\r\n    {\r\n        const ret = [];\r\n        // if there is a piece on (fx,fy) we need to delete it\r\n        boardState.forEach((ele) => {\r\n            if (ele.x === fx && ele.y === fy) {\r\n                // do nothing\r\n            }\r\n            else if (ele.x === px && ele.y === py) {\r\n                const newEle = {...ele};\r\n                newEle.y = fy; newEle.x = fx; ret.push(newEle);\r\n            }\r\n            else {\r\n                const newEle = {...ele};\r\n                ret.push(newEle);\r\n            }\r\n        })\r\n        return ret;\r\n    }\r\n\r\n    isTileOccupied(x, y, boardState) {\r\n        const piece = boardState.find((p) => (p.y === x && p.x === y));\r\n        if (piece) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    isTileOccupiedByOpponent(x, y, boardState, team) {\r\n        const piece = boardState.find((p) => (p.y === x && p.x === y && p.team !== team));\r\n        if (piece) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    isEnPassantMove(py, px, y, x, type, team, boardState) {\r\n        if (\"pawn\" === type) {\r\n            const pawnDirection = \"our\" === team ? 1 : -1;\r\n            if (x - px === 1 || x - px === -1) {\r\n                if (py - y === 1 || py - y === -1) {\r\n                    const enPassantAttackedPiece = boardState.find(p => ((p.y === x) && (p.x === y + pawnDirection) && p.enPassant));\r\n                    if (enPassantAttackedPiece) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // py = initial y coordinate of the moving piece\r\n    // px = initial x coordinate of the moving piece\r\n    // y = y-coordinate of the place where we are moving the piece\r\n    // x = x-coordinate of the place where we are moving the piece\r\n    isValidMove(py, px, y, x, type, team, boardState,oppFlag) {\r\n        if(oppFlag)\r\n        {\r\n            if(team === \"opponent\")\r\n            return false;\r\n        }\r\n\r\n        if (px === x && py === y)\r\n            return false;\r\n\r\n        if (type === \"pawn\") {\r\n            const pawnRow = ((\"our\" === team) ? 6 : 1);\r\n            const pawnDirection = ((\"our\" === team) ? 1 : -1);\r\n            //MOVEMENT LOGIC \r\n            if (py === pawnRow) {\r\n                if (px === x && ((py - y) === 1 * pawnDirection || (py - y) === 2 * pawnDirection)) {\r\n                    let retVal = false;\r\n                    retVal = (py - y) === 1 * pawnDirection ? (!this.isTileOccupied(x, y, boardState)) : ((!this.isTileOccupied(x, y, boardState)) && (!this.isTileOccupied(x, y + pawnDirection, boardState)));\r\n                    return retVal;\r\n                }\r\n                else if (x - px === 1 || x - px === -1) {\r\n                    if (py - y === 1 || py - y === -1) {\r\n                        if (this.isTileOccupiedByOpponent(x, y, boardState, team))\r\n                            return true;\r\n                    }\r\n                }\r\n\r\n            }\r\n            else if (x === px && ((py - y) === 1 * pawnDirection)) {\r\n                return !this.isTileOccupied(x, y, boardState);\r\n            }\r\n            //ATTACKING LOGIC\r\n            else if (x - px === 1 || x - px === -1) {\r\n                if (/*py - y === 1 || py - y === -1*/ (py - y )=== 1 * pawnDirection) {\r\n                    if (this.isTileOccupiedByOpponent(x, y, boardState, team))\r\n                        return true;\r\n                }\r\n            }\r\n        }\r\n        else if (type === \"knight\") {\r\n            const knight_prospects = [[px + 1, py - 2], [px + 1, py + 2], [px + 2, py - 1], [px + 2, py + 1], [px - 1, py - 2], [px - 1, py + 2], [px - 2, py - 1], [px - 2, py + 1]];\r\n            let flag = false;\r\n            for (let i = 0; i <= 7; ++i) {\r\n                const curr = knight_prospects[i];\r\n                if ((x === curr[0] && y === curr[1])) {\r\n                    flag = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (flag === false) {\r\n                return flag;\r\n            }\r\n            else {\r\n                if (this.isTileOccupied(x, y, boardState)) {\r\n                    if (this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                        return true;\r\n                    }\r\n                    else\r\n                        return false;\r\n                }\r\n                else {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else if (\"bishop\" === type) {\r\n            //move and attack logic for the bishop\r\n            //check if the desired position is on a diagonal of the initial position.\r\n           \r\n            const isTheMoveOnDiag = (Math.abs(px - x) === Math.abs(py - y));\r\n            if (!isTheMoveOnDiag)\r\n                return false;\r\n            else {\r\n                const diagDir = [((x - px) > 0 ? 1 : -1), ((y - py) > 0 ? 1 : -1)];\r\n                let curr = [px + diagDir[0], py + diagDir[1]];\r\n                // pieces present in between.\r\n                // c is the number of squares in between.\r\n                let c = Math.abs(x - px) - 1;\r\n                //here we are checking whether the in-between pieces are  blockading or not \r\n                //if they are bloakading then we deem the move invalid\r\n                while (c--) {\r\n                    if (this.isTileOccupied(curr[0], curr[1], boardState)) {\r\n                        return false;\r\n                    }\r\n                    curr[0] += diagDir[0];\r\n                    curr[1] += diagDir[1];\r\n                }\r\n                if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n\r\n        }\r\n        else if (\"rook\" === type) {\r\n            //move and attack logic for the rook\r\n            // check if the desired position is on a horizontal or vertical file of the original position  \r\n            const isTheMoveOnSameFile = (px === x || py === y);\r\n            if (!isTheMoveOnSameFile)\r\n                return false;\r\n            else {\r\n                let curr = [(x === px ? x : ((x > px) ? px + 1 : px - 1)), (y === py ? y : ((y > py ? py + 1 : py - 1)))];\r\n                // pieces present in between.\r\n                // c is the number of squares in between.\r\n                let c = Math.max(Math.abs(x - px), Math.abs(y - py)) - 1;\r\n                //here we are checking whether the in-between pieces are  blockading or not \r\n                //if they are bloakading then we deem the move invalid\r\n                while (c--) {\r\n                    if (this.isTileOccupied(curr[0], curr[1], boardState)) {\r\n                        return false;\r\n                    }\r\n                    let a = curr[0], b = curr[1];\r\n                    curr[0] = (x === px ? a : ((x > px) ? a + 1 : a - 1));\r\n                    curr[1] = (y === py ? b : ((y > py) ? b + 1 : b - 1));\r\n                }\r\n                if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        else if (\"queen\" === type) {\r\n            //move and attack logic for the queen\r\n            // check if the desired position is on a horizontal or vertical file or on one of the diagonals of the original position  \r\n            const isTheMoveOnSameFile = ((px === x || py === y));\r\n            const isTheMoveOnDiag = (Math.abs(px - x) === Math.abs(py - y));\r\n            if (!(isTheMoveOnSameFile || isTheMoveOnDiag))\r\n                return false;\r\n            else {\r\n                if (isTheMoveOnDiag) {\r\n                    const diagDir = [((x - px) > 0 ? 1 : -1), ((y - py) > 0 ? 1 : -1)];\r\n                    let curr = [px + diagDir[0], py + diagDir[1]];\r\n                    // pieces present in between.\r\n                    // c is the number of squares in between.\r\n                    let c = Math.abs(x - px) - 1;\r\n                    //here we are checking whether the in-between pieces are  blockading or not \r\n                    //if they are bloakading then we deem the move invalid\r\n                    while (c--) {\r\n                        if (this.isTileOccupied(curr[0], curr[1], boardState)) {\r\n                            return false;\r\n                        }\r\n                        curr[0] += diagDir[0];\r\n                        curr[1] += diagDir[1];\r\n                    }\r\n                    if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                }\r\n                else {\r\n                    let curr = [(x === px ? x : ((x > px) ? px + 1 : px - 1)), (y === py ? y : ((y > py ? py + 1 : py - 1)))];\r\n                    // pieces present in between.\r\n                    // c is the number of squares in between.\r\n                    let c = Math.max(Math.abs(x - px), Math.abs(y - py)) - 1;\r\n                    //here we are checking whether the in-between pieces are  blockading or not \r\n                    //if they are bloakading then we deem the move invalid\r\n                    while (c--) {\r\n                        if (this.isTileOccupied(curr[0], curr[1], boardState)) {\r\n                            return false;\r\n                        }\r\n                        let a = curr[0], b = curr[1];\r\n                        curr[0] = (x === px ? a : ((x > px) ? a + 1 : a - 1));\r\n                        curr[1] = (y === py ? b : ((y > py) ? b + 1 : b - 1));\r\n                    }\r\n                    if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else if (\"king\" === type) {\r\n            const king_dir = [[px + 1, py], [px, py + 1], [px - 1, py], [px, py - 1], [px + 1, py + 1], [px + 1, py - 1], [px - 1, py - 1], [px - 1, py + 1]];\r\n            const piece = king_dir.find((p) => (p[0] === x && p[1] === y));\r\n            if (piece) {\r\n\r\n            }\r\n            else\r\n                return false;\r\n\r\n            if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                return false;\r\n            }\r\n            return true;\r\n\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}