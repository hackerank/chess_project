{"ast":null,"code":"export default class Referee {\n  inCheck(boardState) {\n    const oppKing = boardState.find(p => p.team === \"opponent\" && p.type === \"king\");\n    if (!oppKing) {\n      return false;\n    }\n    const checkArr = boardState.map(piece => {\n      if (piece.team === \"our\" && this.isValidMove(piece.x, piece.y, oppKing.x, oppKing.y, piece.type, \"our\", boardState)) return true;else return false;\n    });\n    const ret = checkArr.find(ele => ele === true);\n    if (ret) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  isTileOccupied(x, y, boardState) {\n    const piece = boardState.find(p => p.y === x && p.x === y);\n    if (piece) {\n      return true;\n    }\n    return false;\n  }\n  isTileOccupiedByOpponent(x, y, boardState, team) {\n    const piece = boardState.find(p => p.y === x && p.x === y && p.team !== team);\n    if (piece) {\n      return true;\n    }\n    return false;\n  }\n  isEnPassantMove(py, px, y, x, type, team, boardState) {\n    if (\"pawn\" === type) {\n      const pawnDirection = \"our\" === team ? 1 : -1;\n      if (x - px === 1 || x - px === -1) {\n        if (py - y === 1 || py - y === -1) {\n          const enPassantAttackedPiece = boardState.find(p => p.y === x && p.x === y + pawnDirection && p.enPassant);\n          if (enPassantAttackedPiece) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // py = initial y coordinate of the moving piece\n  // px = initial x coordinate of the moving piece\n  // y = y-coordinate of the place where we are moving the piece\n  // x = x-coordinate of the place where we are moving the piece\n  isValidMove(py, px, y, x, type, team, boardState) {\n    {\n      if (\"opponent\" === team) return false;\n      if (type === \"pawn\") {\n        const pawnRow = \"our\" === team ? 6 : 1;\n        const pawnDirection = \"our\" === team ? 1 : -1;\n        //MOVEMENT LOGIC \n        if (py === pawnRow) {\n          if (px === x && (py - y === 1 * pawnDirection || py - y === 2 * pawnDirection)) {\n            let retVal = false;\n            retVal = py - y === 1 * pawnDirection ? !this.isTileOccupied(x, y, boardState) : !this.isTileOccupied(x, y, boardState) && !this.isTileOccupied(x, y + pawnDirection, boardState);\n            return retVal;\n          } else if (x - px === 1 || x - px === -1) {\n            if (py - y === 1 || py - y === -1) {\n              if (this.isTileOccupiedByOpponent(x, y, boardState, team)) return true;\n            }\n          }\n        } else if (x === px && py - y === 1 * pawnDirection) {\n          return !this.isTileOccupied(x, y, boardState);\n        }\n        //ATTACKING LOGIC\n        else if (x - px === 1 || x - px === -1) {\n          if (py - y === 1 || py - y === -1) {\n            if (this.isTileOccupiedByOpponent(x, y, boardState, team)) return true;\n          }\n        }\n      } else if (type === \"knight\") {\n        const knight_prospects = [[px + 1, py - 2], [px + 1, py + 2], [px + 2, py - 1], [px + 2, py + 1], [px - 1, py - 2], [px - 1, py + 2], [px - 2, py - 1], [px - 2, py + 1]];\n        let flag = false;\n        for (let i = 0; i <= 7; ++i) {\n          const curr = knight_prospects[i];\n          if (x === curr[0] && y === curr[1]) {\n            flag = true;\n            break;\n          }\n        }\n        if (flag === false) {\n          return flag;\n        } else {\n          if (this.isTileOccupied(x, y, boardState)) {\n            if (this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n              return true;\n            } else return false;\n          } else {\n            return true;\n          }\n        }\n      } else if (\"bishop\" === type) {\n        //move and attack logic for the bishop\n        //check if the desired position is on a diagonal of the initial position.\n        const isTheMoveOnDiag = Math.abs(px - x) === Math.abs(py - y);\n        if (!isTheMoveOnDiag) return false;else {\n          const diagDir = [x - px > 0 ? 1 : -1, y - py > 0 ? 1 : -1];\n          let curr = [px + diagDir[0], py + diagDir[1]];\n          // pieces present in between.\n          // c is the number of squares in between.\n          let c = Math.abs(x - px) - 1;\n          //here we are checking whether the in-between pieces are  blockading or not \n          //if they are bloakading then we deem the move invalid\n          while (c--) {\n            if (this.isTileOccupied(curr[0], curr[1], boardState)) {\n              return false;\n            }\n            curr[0] += diagDir[0];\n            curr[1] += diagDir[1];\n          }\n          if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n            return false;\n          }\n          return true;\n        }\n      } else if (\"rook\" === type) {\n        //move and attack logic for the rook\n        // check if the desired position is on a horizontal or vertical file of the original position  \n        const isTheMoveOnSameFile = px === x || py === y;\n        if (!isTheMoveOnSameFile) return false;else {\n          let curr = [x === px ? x : x > px ? px + 1 : px - 1, y === py ? y : y > py ? py + 1 : py - 1];\n          // pieces present in between.\n          // c is the number of squares in between.\n          let c = Math.max(Math.abs(x - px), Math.abs(y - py)) - 1;\n          //here we are checking whether the in-between pieces are  blockading or not \n          //if they are bloakading then we deem the move invalid\n          while (c--) {\n            if (this.isTileOccupied(curr[0], curr[1], boardState)) {\n              return false;\n            }\n            let a = curr[0],\n              b = curr[1];\n            curr[0] = x === px ? a : x > px ? a + 1 : a - 1;\n            curr[1] = y === py ? b : y > py ? b + 1 : b - 1;\n          }\n          if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n            return false;\n          }\n          return true;\n        }\n      } else if (\"queen\" === type) {\n        //move and attack logic for the queen\n        // check if the desired position is on a horizontal or vertical file or on one of the diagonals of the original position  \n        const isTheMoveOnSameFile = px === x || py === y;\n        const isTheMoveOnDiag = Math.abs(px - x) === Math.abs(py - y);\n        if (!(isTheMoveOnSameFile || isTheMoveOnDiag)) return false;else {\n          if (isTheMoveOnDiag) {\n            const diagDir = [x - px > 0 ? 1 : -1, y - py > 0 ? 1 : -1];\n            let curr = [px + diagDir[0], py + diagDir[1]];\n            // pieces present in between.\n            // c is the number of squares in between.\n            let c = Math.abs(x - px) - 1;\n            //here we are checking whether the in-between pieces are  blockading or not \n            //if they are bloakading then we deem the move invalid\n            while (c--) {\n              if (this.isTileOccupied(curr[0], curr[1], boardState)) {\n                return false;\n              }\n              curr[0] += diagDir[0];\n              curr[1] += diagDir[1];\n            }\n            if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n              return false;\n            }\n            return true;\n          } else {\n            let curr = [x === px ? x : x > px ? px + 1 : px - 1, y === py ? y : y > py ? py + 1 : py - 1];\n            // pieces present in between.\n            // c is the number of squares in between.\n            let c = Math.max(Math.abs(x - px), Math.abs(y - py)) - 1;\n            //here we are checking whether the in-between pieces are  blockading or not \n            //if they are bloakading then we deem the move invalid\n            while (c--) {\n              if (this.isTileOccupied(curr[0], curr[1], boardState)) {\n                return false;\n              }\n              let a = curr[0],\n                b = curr[1];\n              curr[0] = x === px ? a : x > px ? a + 1 : a - 1;\n              curr[1] = y === py ? b : y > py ? b + 1 : b - 1;\n            }\n            if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n              return false;\n            }\n            return true;\n          }\n        }\n      } else if (\"king\" === type) {\n        const king_dir = [[px + 1, py], [px, py + 1], [px - 1, py], [px, py - 1], [px + 1, py + 1], [px + 1, py - 1], [px - 1, py - 1], [px - 1, py + 1]];\n        const piece = king_dir.find(p => p[0] === x && p[1] === y);\n        if (piece) {} else return false;\n        if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\n          return false;\n        }\n        return true;\n      }\n      return false;\n    }\n  }\n}","map":{"version":3,"names":["Referee","inCheck","boardState","oppKing","find","p","team","type","checkArr","map","piece","isValidMove","x","y","ret","ele","isTileOccupied","isTileOccupiedByOpponent","isEnPassantMove","py","px","pawnDirection","enPassantAttackedPiece","enPassant","pawnRow","retVal","knight_prospects","flag","i","curr","isTheMoveOnDiag","Math","abs","diagDir","c","isTheMoveOnSameFile","max","a","b","king_dir"],"sources":["C:/Users/think/Desktop/Projects/Chess Project/frontend/chess-frontend/src/Components/Referee.js"],"sourcesContent":["\r\nexport default class Referee {\r\n    inCheck(boardState) {\r\n        const oppKing = boardState.find((p) => (p.team === \"opponent\" && p.type === \"king\"));\r\n        if (!oppKing) {\r\n            return false;\r\n        }\r\n        const checkArr = boardState.map(piece => {\r\n            if (piece.team === \"our\" && this.isValidMove(piece.x, piece.y, oppKing.x, oppKing.y, piece.type, \"our\", boardState))\r\n                return true;\r\n            else\r\n                return false;\r\n        });\r\n        const ret = checkArr.find((ele) => (ele === true));\r\n        if (ret) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    isTileOccupied(x, y, boardState) {\r\n        const piece = boardState.find((p) => (p.y === x && p.x === y));\r\n        if (piece) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    isTileOccupiedByOpponent(x, y, boardState, team) {\r\n        const piece = boardState.find((p) => (p.y === x && p.x === y && p.team !== team));\r\n        if (piece) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    isEnPassantMove(py, px, y, x, type, team, boardState) {\r\n        if (\"pawn\" === type) {\r\n            const pawnDirection = \"our\" === team ? 1 : -1;\r\n            if (x - px === 1 || x - px === -1) {\r\n                if (py - y === 1 || py - y === -1) {\r\n                    const enPassantAttackedPiece = boardState.find(p => ((p.y === x) && (p.x === y + pawnDirection) && p.enPassant));\r\n                    if (enPassantAttackedPiece) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    // py = initial y coordinate of the moving piece\r\n    // px = initial x coordinate of the moving piece\r\n    // y = y-coordinate of the place where we are moving the piece\r\n    // x = x-coordinate of the place where we are moving the piece\r\n    isValidMove(py, px, y, x, type, team, boardState) {\r\n        \r\n        {if (\"opponent\" === team)\r\n            return false;\r\n        \r\n        if (type === \"pawn\") {\r\n            const pawnRow = ((\"our\" === team) ? 6 : 1);\r\n            const pawnDirection = ((\"our\" === team) ? 1 : -1);\r\n            //MOVEMENT LOGIC \r\n            if (py === pawnRow) {\r\n                if (px === x && ((py - y) === 1 * pawnDirection || (py - y) === 2 * pawnDirection)) {\r\n                    let retVal = false;\r\n                    retVal = (py - y) === 1 * pawnDirection ? (!this.isTileOccupied(x, y, boardState)) : ((!this.isTileOccupied(x, y, boardState)) && (!this.isTileOccupied(x, y + pawnDirection, boardState)));\r\n                    return retVal;\r\n                }\r\n                else if (x - px === 1 || x - px === -1) {\r\n                    if (py - y === 1 || py - y === -1) {\r\n                        if (this.isTileOccupiedByOpponent(x, y, boardState, team))\r\n                            return true;\r\n                    }\r\n                }\r\n\r\n            }\r\n            else if (x === px && ((py - y) === 1 * pawnDirection)) {\r\n                return !this.isTileOccupied(x, y, boardState);\r\n            }\r\n            //ATTACKING LOGIC\r\n            else if (x - px === 1 || x - px === -1) {\r\n                if (py - y === 1 || py - y === -1) {\r\n                    if (this.isTileOccupiedByOpponent(x, y, boardState, team))\r\n                        return true;\r\n                }\r\n            }\r\n        }\r\n        else if (type === \"knight\") {\r\n            const knight_prospects = [[px + 1, py - 2], [px + 1, py + 2], [px + 2, py - 1], [px + 2, py + 1], [px - 1, py - 2], [px - 1, py + 2], [px - 2, py - 1], [px - 2, py + 1]];\r\n            let flag = false;\r\n            for (let i = 0; i <= 7; ++i) {\r\n                const curr = knight_prospects[i];\r\n                if ((x === curr[0] && y === curr[1])) {\r\n                    flag = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (flag === false) {\r\n                return flag;\r\n            }\r\n            else {\r\n                if (this.isTileOccupied(x, y, boardState)) {\r\n                    if (this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                        return true;\r\n                    }\r\n                    else\r\n                        return false;\r\n                }\r\n                else {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else if (\"bishop\" === type) {\r\n            //move and attack logic for the bishop\r\n            //check if the desired position is on a diagonal of the initial position.\r\n            const isTheMoveOnDiag = (Math.abs(px - x) === Math.abs(py - y));\r\n            if (!isTheMoveOnDiag)\r\n                return false;\r\n            else {\r\n                const diagDir = [((x - px) > 0 ? 1 : -1), ((y - py) > 0 ? 1 : -1)];\r\n                let curr = [px + diagDir[0], py + diagDir[1]];\r\n                // pieces present in between.\r\n                // c is the number of squares in between.\r\n                let c = Math.abs(x - px) - 1;\r\n                //here we are checking whether the in-between pieces are  blockading or not \r\n                //if they are bloakading then we deem the move invalid\r\n                while (c--) {\r\n                    if (this.isTileOccupied(curr[0], curr[1], boardState)) {\r\n                        return false;\r\n                    }\r\n                    curr[0] += diagDir[0];\r\n                    curr[1] += diagDir[1];\r\n                }\r\n                if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n\r\n        }\r\n        else if (\"rook\" === type) {\r\n            //move and attack logic for the rook\r\n            // check if the desired position is on a horizontal or vertical file of the original position  \r\n            const isTheMoveOnSameFile = (px === x || py === y);\r\n            if (!isTheMoveOnSameFile)\r\n                return false;\r\n            else {\r\n                let curr = [(x === px ? x : ((x > px) ? px + 1 : px - 1)), (y === py ? y : ((y > py ? py + 1 : py - 1)))];\r\n                // pieces present in between.\r\n                // c is the number of squares in between.\r\n                let c = Math.max(Math.abs(x - px), Math.abs(y - py)) - 1;\r\n                //here we are checking whether the in-between pieces are  blockading or not \r\n                //if they are bloakading then we deem the move invalid\r\n                while (c--) {\r\n                    if (this.isTileOccupied(curr[0], curr[1], boardState)) {\r\n                        return false;\r\n                    }\r\n                    let a = curr[0], b = curr[1];\r\n                    curr[0] = (x === px ? a : ((x > px) ? a + 1 : a - 1));\r\n                    curr[1] = (y === py ? b : ((y > py) ? b + 1 : b - 1));\r\n                }\r\n                if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                    return false;\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        else if (\"queen\" === type) {\r\n            //move and attack logic for the queen\r\n            // check if the desired position is on a horizontal or vertical file or on one of the diagonals of the original position  \r\n            const isTheMoveOnSameFile = ((px === x || py === y));\r\n            const isTheMoveOnDiag = (Math.abs(px - x) === Math.abs(py - y));\r\n            if (!(isTheMoveOnSameFile || isTheMoveOnDiag))\r\n                return false;\r\n            else {\r\n                if (isTheMoveOnDiag) {\r\n                    const diagDir = [((x - px) > 0 ? 1 : -1), ((y - py) > 0 ? 1 : -1)];\r\n                    let curr = [px + diagDir[0], py + diagDir[1]];\r\n                    // pieces present in between.\r\n                    // c is the number of squares in between.\r\n                    let c = Math.abs(x - px) - 1;\r\n                    //here we are checking whether the in-between pieces are  blockading or not \r\n                    //if they are bloakading then we deem the move invalid\r\n                    while (c--) {\r\n                        if (this.isTileOccupied(curr[0], curr[1], boardState)) {\r\n                            return false;\r\n                        }\r\n                        curr[0] += diagDir[0];\r\n                        curr[1] += diagDir[1];\r\n                    }\r\n                    if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                }\r\n                else {\r\n                    let curr = [(x === px ? x : ((x > px) ? px + 1 : px - 1)), (y === py ? y : ((y > py ? py + 1 : py - 1)))];\r\n                    // pieces present in between.\r\n                    // c is the number of squares in between.\r\n                    let c = Math.max(Math.abs(x - px), Math.abs(y - py)) - 1;\r\n                    //here we are checking whether the in-between pieces are  blockading or not \r\n                    //if they are bloakading then we deem the move invalid\r\n                    while (c--) {\r\n                        if (this.isTileOccupied(curr[0], curr[1], boardState)) {\r\n                            return false;\r\n                        }\r\n                        let a = curr[0], b = curr[1];\r\n                        curr[0] = (x === px ? a : ((x > px) ? a + 1 : a - 1));\r\n                        curr[1] = (y === py ? b : ((y > py) ? b + 1 : b - 1));\r\n                    }\r\n                    if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                        return false;\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else if (\"king\" === type) {\r\n            const king_dir = [[px + 1, py], [px, py + 1], [px - 1, py], [px, py - 1], [px + 1, py + 1], [px + 1, py - 1], [px - 1, py - 1], [px - 1, py + 1]];\r\n            const piece = king_dir.find((p) => (p[0] === x && p[1] === y));\r\n            if (piece) {\r\n\r\n            }\r\n            else\r\n                return false;\r\n\r\n            if (this.isTileOccupied(x, y, boardState) && !this.isTileOccupiedByOpponent(x, y, boardState, team)) {\r\n                return false;\r\n            }\r\n            return true;\r\n\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n}\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}